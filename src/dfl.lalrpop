use std::str::FromStr;
use std::rc::Rc;

use crate::ast::*;

grammar;

match {
    r"\s*" => {}, // The default whitespace skipping is disabled if an `ignore pattern` is specified
    r"//[^\n\r]*[\n\r]*" => {}, // Skip `// comments`
    r"/\*[^*]*\*+(?:[^/*][^*]*\*+)*/" => {},  // Skip `/* comments */`
    _
}

CommaSep<T>: Vec<T> = {
    <mut v:(<T> ",")*> <e:T?> => match e {
        None => v,
        Some(e) => {
            v.push(e);
            v
        }
    }
}

pub Bool: bool = { "false" => false, "true" => true }
pub Int: i32 = { r"0|-?[1-9][0-9]*" => i32::from_str(<>).unwrap() }
pub Var: Var = { r"[a-zA-Z_][a-zA-Z0-9_']*" => Var(String::from_str(<>).unwrap()) }
pub ChanName: ChanName = { r"[a-zA-Z_][a-zA-Z0-9_']*" => ChanName(String::from_str(<>).unwrap()) }
pub ProcName: ProcName = { r"[a-zA-Z_][a-zA-Z0-9_']*"  => ProcName(String::from_str(<>).unwrap()) }
pub MutName: MutName = { r"[a-zA-Z_][a-zA-Z0-9_']*" => MutName(String::from_str(<>).unwrap()) }

pub ProcParam: (Var, BaseType) = {
    "(" <v:Var> ":" <t:BaseType> ")" => (v, t),
}

pub ProcParams: ProcParams = {
    ProcParam* => ProcParams { params: <> },
}

pub BaseType: BaseType = {
    "bool" => BaseType::Bool,
    "int" => BaseType::Int,
}

pub MutType: MutType = {
    <t:BaseType> => MutType::Base(t),
    "[" <t:BaseType> "]" => MutType::Array(t),
}

pub PermFraction: PermFraction = {
    "write" => PermFraction::Write,
    "read" => PermFraction::Read(0),
}

pub MutReference: MutReference = {
    MutName => MutReference::Base(<>),
    <n:MutName> "[" <t:Term> "]" => MutReference::Index(n, t),
    <n:MutName> "[" <t1:Term?> ".." <t2:Term?> "]" => MutReference::Slice(n, t1, t2),
}

pub Permission: Permission = {
    #[precedence(level = "0")]
    "empty" => Rc::new(PermissionX::Empty),
    <f:PermFraction> <r:MutReference> => Rc::new(PermissionX::Fraction(f, r)),
    "(" <p:Permission> ")" => p,
    
    "if" <t:Term> "then" <p1:Permission> "else" <p2:Permission> "end" => Rc::new(PermissionX::Ite(t, p1, p2)),

    #[precedence(level = "1")]
    #[assoc(side="left")]
    <p1:Permission> "+" <p2:Permission> => Rc::new(PermissionX::Add(p1, p2)),
}

pub Term: Term = {
    #[precedence(level = "0")]
    Var => Rc::new(TermX::Var(<>)),
    Bool => Rc::new(TermX::Bool(<>)),
    Int => Rc::new(TermX::Int(<>)),

    #[precedence(level = "1")]
    #[assoc(side="left")]
    <t1:Term> "*" <t2:Term> => Rc::new(TermX::Add(t1, t2)),

    #[precedence(level = "2")]
    #[assoc(side="left")]
    <t1:Term> "+" <t2:Term> => Rc::new(TermX::Mul(t1, t2)),

    #[precedence(level = "3")]
    #[assoc(side="left")]
    <t1:Term> "<" <t2:Term> => Rc::new(TermX::Less(t1, t2)),
    #[assoc(side="left")]
    <t1:Term> "=" <t2:Term> => Rc::new(TermX::Equal(t1, t2)),

    #[precedence(level = "4")]
    "not" <t:Term> => Rc::new(TermX::Not(t)),
    
    #[precedence(level = "5")]
    #[assoc(side="left")]
    <t1:Term> "and" <t2:Term> => Rc::new(TermX::And(t1, t2)),
}

pub Proc: Proc = {
    #[precedence(level = "0")]
    "skip" => Rc::new(ProcX::Skip),
    "send" <t:Term> "->" <c:ChanName> ";" <k:Proc> => Rc::new(ProcX::Send(c, t, k)),
    "recv" <x:Var> "<-" <c:ChanName> ";" <k:Proc> => Rc::new(ProcX::Recv(c, x, k)),
    "write" <t:Term> "->" <m:MutReference> ";" <k:Proc> => Rc::new(ProcX::Write(m, t, k)),
    "read" <x:Var> "<-" <m:MutReference> ";" <k:Proc> => Rc::new(ProcX::Read(m, x, k)),
    "if" <t:Term> "then" <k1:Proc> "else" <k2:Proc> "end" => Rc::new(ProcX::Ite(t, k1, k2)),
    <p:ProcName> <args:Term*> => Rc::new(ProcX::Call(p, args)),
    "(" <p:Proc> ")" => p,
    
    #[precedence(level = "1")]
    #[assoc(side="right")]
    <k1:Proc> "||" <k2:Proc> => Rc::new(ProcX::Par(k1, k2)),
}

pub ProcResource: ProcResource = {
    Permission => Rc::new(ProcResourceX::Perm(<>)),
    "input" <n:ChanName> => Rc::new(ProcResourceX::Input(n)),
    "output" <n:ChanName> => Rc::new(ProcResourceX::Output(n)),
}

pub Decl: Decl = {
    "mut" <n:MutName> ":" <t:MutType> => Decl::Mut(Rc::new(MutDeclX { name: n, typ: t })),
    "chan" <n:ChanName> ":" <t:BaseType> "|" <p:Permission> =>
        Decl::Chan(Rc::new(ChanDeclX { name: n, typ: t, perm: p })),
    "proc" <n:ProcName> <p:ProcParams> "|" <r:CommaSep<ProcResource>> "=" <b:Proc> =>
        Decl::Proc(Rc::new(ProcDeclX { name: n, params: p, res: r, body: b })),
    "proc" <n:ProcName> <p:ProcParams> "=" <b:Proc> =>
        Decl::Proc(Rc::new(ProcDeclX { name: n, params: p, res: Vec::new(), body: b })),
}

pub Program: Program = { Decl* => Program { decls: <> } }
