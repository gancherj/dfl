use std::str::FromStr;
use std::rc::Rc;

use crate::ast::*;

grammar;

match {
    r"\s*" => {}, // The default whitespace skipping is disabled if an `ignore pattern` is specified
    r"//[^\n\r]*[\n\r]*" => {}, // Skip `// comments`
    r"/\*[^*]*\*+(?:[^/*][^*]*\*+)*/" => {},  // Skip `/* comments */`
    _
}

CommaSep<T>: Vec<T> = {
    <mut v:(<T> ",")*> <e:T?> => match e {
        None => v,
        Some(e) => {
            v.push(e);
            v
        }
    }
}

Bool: bool = { "false" => false, "true" => true }
PositiveInt: u32 = {
    r"[1-9][0-9]*" => u32::from_str(<>).unwrap(),
}
UnsignedInt: u32 = {
    PositiveInt,
    "0" => 0,
}
Int: i64 = {
    UnsignedInt => <>.into(),
    "-?[1-9][0-9]*" => i64::from_str(<>).unwrap(),
}
Var: Var = { r"[a-zA-Z_][a-zA-Z0-9_']*" => Var(<>.into()) }
Const: Const = { r"[a-zA-Z_][a-zA-Z0-9_']*" => Const(<>.into()) }
ChanName: ChanName = { r"[a-zA-Z_][a-zA-Z0-9_']*" => ChanName(<>.into()) }
ProcName: ProcName = { r"[a-zA-Z_][a-zA-Z0-9_']*"  => ProcName(<>.into()) }
MutName: MutName = { r"[a-zA-Z_][a-zA-Z0-9_']*" => MutName(<>.into()) }

BaseType: BaseType = {
    "bool" => BaseType::Bool,
    "int" => BaseType::Int,
}

BaseTypeWithRef: BaseType = {
    BaseType,
    "&" <n:MutName> <l:("[""*""]")*> => BaseType::Ref(Rc::new([n]), l.len()),
    "&" "{" <ns:CommaSep<MutName>> "}" <l:("[""*""]")*> => BaseType::Ref(ns.into(), l.len()),
}

MutType: MutType = {
    <t:BaseType> => Rc::new(MutTypeX::Base(t)),
    "[" <t:MutType> "]" => Rc::new(MutTypeX::Array(t)),
}

ProcParam: ProcParam = {
    "(" <v:Var> ":" <t:BaseTypeWithRef> ")" => ProcParam { name: v, typ: t },
}

PermFraction: PermFraction = {
    "write" => PermFraction::Write,
    "read" "(" <k:PositiveInt> ")" => PermFraction::Read(k),
}

MutReference: MutReference = {
    MutName => Rc::new(MutReferenceX::Base(<>)),
    "*" <t:AtomicTerm> => Rc::new(MutReferenceX::Deref(t)),
    <m:MutReference> "[" <t:Term> "]" => Rc::new(MutReferenceX::Index(m, t)),
    <m:MutReference> "[" <t1:Term?> ".." <t2:Term?> "]" => Rc::new(MutReferenceX::Slice(m, t1, t2)),
}

PermissionReset = <Permission>;
Permission: Permission = {
    #[precedence(level = "0")]
    "empty" => Rc::new(PermissionX::Empty),
    <f:PermFraction> <r:MutReference> => Rc::new(PermissionX::Fraction(f, r)),
    "if" <t:Term> "then" <p1:Permission> "else" <p2:Permission> "end" => Rc::new(PermissionX::Ite(t, p1, p2)),
    "(" <p:PermissionReset> ")" => p,

    #[precedence(level = "1")]
    #[assoc(side="left")]
    <p1:Permission> "+" <p2:Permission> => Rc::new(PermissionX::Add(p1, p2)),
}

TermReset = <Term>;
AtomicTerm: Term = {
    Var => Rc::new(TermX::Var(<>)), // Both variables and constants are parsed as variables first, and constants are then converted later
    Bool => Rc::new(TermX::Bool(<>)),
    Int => Rc::new(TermX::Int(<>)),
    "(" <t:TermReset> ")" => t,
}
Term: Term = {
    #[precedence(level = "0")]
    AtomicTerm,
    "&" <m:MutReference> => Rc::new(TermX::Ref(m)),

    #[precedence(level = "1")]
    #[assoc(side="left")]
    <t1:Term> "*" <t2:Term> => Rc::new(TermX::Mul(t1, t2)),

    #[precedence(level = "2")]
    #[assoc(side="left")]
    <t1:Term> "+" <t2:Term> => Rc::new(TermX::Add(t1, t2)),

    #[precedence(level = "3")]
    #[assoc(side="left")]
    <t1:Term> "<" <t2:Term> => Rc::new(TermX::Less(t1, t2)),
    #[assoc(side="left")]
    <t1:Term> "=" <t2:Term> => Rc::new(TermX::Equal(t1, t2)),

    #[precedence(level = "4")]
    "not" <t:Term> => Rc::new(TermX::Not(t)),
    
    #[precedence(level = "5")]
    #[assoc(side="left")]
    <t1:Term> "and" <t2:Term> => Rc::new(TermX::And(t1, t2)),
}

ProcReset = <Proc>;
Proc: Proc = {
    #[precedence(level = "0")]
    "skip" => Rc::new(ProcX::Skip),
    "send" <t:Term> "->" <c:ChanName> <k:Proc?> => Rc::new(ProcX::Send(c, t, k.unwrap_or(Rc::new(ProcX::Skip)))),
    "recv" <x:Var> "<-" <c:ChanName> <k:Proc?> => Rc::new(ProcX::Recv(c, x, k.unwrap_or(Rc::new(ProcX::Skip)))),
    "write" <t:Term> "->" <m:MutReference> <k:Proc?> => Rc::new(ProcX::Write(m, t, k.unwrap_or(Rc::new(ProcX::Skip)))),
    "read" <x:Var> "<-" <m:MutReference> <k:Proc?> => Rc::new(ProcX::Read(m, x, k.unwrap_or(Rc::new(ProcX::Skip)))),
    "debug" <k:Proc?> => Rc::new(ProcX::Debug(k.unwrap_or(Rc::new(ProcX::Skip)))),

    "if" <t:Term> "then" <k1:Proc> "else" <k2:Proc> "end" => Rc::new(ProcX::Ite(t, k1, k2)),
    "if" <t:Term> "then" <k:Proc> "end" => Rc::new(ProcX::Ite(t, k, Rc::new(ProcX::Skip))),
    <p:ProcName> <args:Term*> => Rc::new(ProcX::Call(p, args)),

    "(" <p:ProcReset> ")" => p,

    #[precedence(level = "1")]
    #[assoc(side="right")]
    <k1:Proc> "||" <k2:Proc> => Rc::new(ProcX::Par(k1, k2)),
}

ProcResource: ProcResource = {
    Permission => Rc::new(ProcResourceX::Perm(<>)),
    "in" <n:ChanName> => Rc::new(ProcResourceX::Input(n)),
    "out" <n:ChanName> => Rc::new(ProcResourceX::Output(n)),
}

Decl: Decl = {
    "const" <n:Const> ":" <t:BaseTypeWithRef> => Decl::Const(Rc::new(ConstDeclX { name: n, typ: t })),
    "mut" <n:MutName> ":" <t:MutType> => Decl::Mut(Rc::new(MutDeclX { name: n, typ: t })),
    "chan" <n:ChanName> ":" <t:BaseTypeWithRef> "|" <p:Permission> =>
        Decl::Chan(Rc::new(ChanDeclX { name: n, typ: t, perm: p })),
    "chan" <n:ChanName> ":" <t:BaseTypeWithRef> =>
        Decl::Chan(Rc::new(ChanDeclX { name: n, typ: t, perm: Rc::new(PermissionX::Empty) })),
    "proc" <n:ProcName> <p:CommaSep<ProcParam>> "|" <r:CommaSep<ProcResource>> "=" <b:Proc> =>
        Decl::Proc(Rc::new(ProcDeclX { name: n, params: p, res: r, all_res: false, body: b })),
    "proc" <n:ProcName> <p:CommaSep<ProcParam>> "=" <b:Proc> =>
        Decl::Proc(Rc::new(ProcDeclX { name: n, params: p, res: Vec::new(), all_res: false, body: b })),
    "proc" <n:ProcName> <p:CommaSep<ProcParam>> "|" "all" "=" <b:Proc> =>
        Decl::Proc(Rc::new(ProcDeclX { name: n, params: p, res: Vec::new(), all_res: true, body: b })),
}

pub Program: Program = { Decl* => Program { decls: <> } }
